#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
#include <unordered_map>
#include <queue>
#include <map>
using namespace std;
/*
*也可以写两种。这里含前导0因为简单。第二种懒得写了。注意数组错位。
*这题和392很像，但是区别也较大。区别在哪呢？392是判断是不是子序列。而115是看能组成几个。
?这代表了什么
!这代表了dp数组的含义不同
TODO: 392的dp数组的含义是：dp[i][j]表示以下标i-1为结尾的字符串s，和以下标j-1为结尾的字符串t，//!相同子序列的长度为dp[i][j]。
TODO: 这里115的dp数组的含义是：dp[i][j]表示以下标i-1为结尾的字符串s中出现以下标j-1为结尾的字符串t的 //!个数为dp[i][j]。
*我们可以发现，一个是长度，一个是个数。这也就解释了递推公式不一样的原因。

TODO：392里面当最后位相等的时候，我们的公式是 dp[i][j] = dp[i-1][j-1] + 1; 
这里+1的原因是我们计算的是长度。所以这个当下字符匹配长度就+1.//!最关键的是我们没有必要去选择在相等的时候要不要匹配这个字符。因为就算有多个重复的，我们仅需判断是子串的一种即可。所以不需要分开计算选择取这位和不取这位时候的长度。

TODO: 这里115我们是计算的个数。//!当 当前位字母相等的时候，这里我们需要分开计算是否选择当前位进行匹配。举例：abc 和 abbbbc。我们在第二个b的时候需要选择是以当前位b匹配或者是不以当前位匹配。因为这是两种情况。
所以我们有dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                        ↑               ↑
            这里是让当前字符参与匹配    这里是不让当前字符参与匹配
            也就是用这个s的意思。       也就是不用这个s的意思。所以是i-1(不用这个s) 和j(用这个t)
            用这个s就需要从上一个相等的地方匹配。所以是i-1和j-1


            !这道题s比t长也就是从s里头找t

?   t→       
? s↓--------------------------------------------
?
?   --------------------------------------------
?                     [i-1][j-1]|[i-1][j]                          [i-1][j]也就是要当前t位不要当前s位
?   --------------------------------------------
?                      [i][j-1] |[i][j]                            [i][j-1]也就是要当前s位不要当前t位
?   --------------------------------------------

我们从上图能看到。如果当前字符相等的时候，如果需要当前字符进行匹配，就需要从i-1 j-1也就是上一个匹配状态进行推导。也就是看i-1 j-1的时候有几个现在就还是几个。
举个例子 abcde和 abc匹配
当我们只看到a为止的时候，a和a匹配。所以是一种
当我们继续看到b为止的时候，ab和ab匹配。这里不能加1。因为我们不是长度是个数。个数是什么意思呢？a和a匹配和ab和ab匹配他俩其实是一个东西。因为b是接在a后面的。
当我们继续看到c为止的时候，abc和abc匹配。这里还是一种，因为abc是一种东西，不能拆开看a， ab， abc。这不是三种。
所以我们发现相等的时候仅需记录状态这是一种可以匹配的子序列。但是种类并没有+1。所以就是dp[i-1][j-1]

因为是从s里面找t。所以我们要从s里面扣掉。所以就是[i-1][j]时候的状态

所以我们递推公式就是dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
8/6更新：这句话的意思是 abcd和bcdf两个匹配到b的时候，如果当前bcd的b选择和abcd的b匹配，则成功匹配的数量是bcd的b之前的字符串成功匹配的数量。这里也就是1因为有初始化
                                                    如果当前bcd的b选的不匹配，则能成功匹配的数量是bcd的b之前和abcd的b之前子字符串成功匹配的数量。也就是0
                    如果当前字符不对，比如abcd的d和abce的e匹配，则没有选择余地。abcd的d 和 abce的e匹配成功数量等于这个字符之前匹配成功的数量也就是abc和abcd的成功次数。和上面的不匹配一样。

*同理。因为是s里面找t。所以当前字符不相等的时候也是从s里面抠掉。所以也是dp[i][j] = dp[i-1][j]


参考：https://leetcode.cn/problems/distinct-subsequences/solution/dong-tai-gui-hua-yi-ci-ti-wei-li-jiang-j-enq0/


*/




class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size()+1, vector<uint64_t>(t.size()+1,0));

        for(int i = 0; i <s.size()+1; i++){
            dp[i][0] = 1;
        }

        for(int i = 1; i < s.size()+1; i++){
            for(int j = 1; j <t.size()+1; j++){
                if(s[i-1] == t[j-1]){
                    dp[i][j] = dp[i-1][j-1] + dp[i-1][j];
                }
                else{
                    dp[i][j] = dp[i-1][j];
                }
            }
        }
        return dp[s.size()][t.size()];
    }
};



