#include <iostream>
#include <string>
#include <memory>
#include <queue>
#include <vector>
#include <functional>
#include <algorithm>

using namespace std;
class Solution {
public:
    int numTrees(int n) {
        if(n == 0){
            return 1;
        }
        if(n == 1){
            return 1;
        }
        vector<int> dp(n+1);
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3; i <=n; i++){
            for(int j = 1; j <=i; j++){
                dp[i] = dp[i] + dp[j-1] * dp[i-j];
            }
        }
        return dp[n];
    }
};
/*
这道题非常难，可以多看题解。
首先 n代表 n个节点可以组成多少种二叉搜索树。注意是二叉搜索树，所以左小右大。
dp[i]这里的i可以理解为节点数量，所以dp[i]的意思是有i个节点的二叉搜索树，有多少种。
注意是组合，所以左右两边分支是相乘关系。
dp[0] 节点个数为0的搜索树有几种？答案是一种。没有也是一种
dp[1] 节点个数为1的搜索树有一种       1

dp[2] 节点个数为2的搜索树有两种。  dp[1] * dp[0] + dp[0] * dp[1] = 1 * 1 + 1 * 1
以1为头结点的时候 1  或者  以2为头结点的时候 2
                \                    /
                 2                  1
注意。左子树没有节点所以是dp[0]            右子树没有节点所以是dp[0]      
     右子树有1个节点所以是dp[1]           左子树有1个节点所以是dp[1]
     因为是组合所以是dp[0] * dp[1]
dp[3] 节点个数为3的搜索树5种。 dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0]
    以1为头结点：dp[0]* dp[2]  这里为什么是一种？因为我们是从1节点开始看，1的左子树都没有东西，只有右子树有。不要去管下面的左右，只看当前这一层。
        1                       1
         \                       \
          2                        3
           \                      /
            3                    2   

    以2为头结点: dp[1] * dp[1]
        2
       / \
      1   3

    以3为头结点: dp[2] * dp[0] 因为从3节点开始看，3的右子树都没有 只有左子树有 所以是dp[2] * dp[0]
        3                       3
       /                       / 
      2                       1  
     /                         \
    1                           2

我们已经掌握了基本的东西。开始研究递推
我们已经设定以i为根节点。所以左子树一定是从1到i 一共i-1个, 右子树一定是从i到n 一共n-i个

我们有两层for循环
for(int i = 3; i <=n; i++){
    for(int j = 1; j <=i; j++){
        dp[i] = dp[i] + dp[j-1] * dp[i-j];
    }
}
外层的i是在统计有i个节点的二叉搜索树有几种. 所以i的范围是从basecase+1到n。这里basecase是到2。
内层的j是在具体累加，以j为头结点的时候一共有几种组合方式。所以范围是1到i
假设n=3，我们已经算完了basecase即dp[0],dp[1],dp[2]，所以我们直接开始算dp[3] 即有三个节点的二叉搜索树有几种。
所以第一层只有一次循环，我们进入内层循环。
j的范围是1到3所以是:
第一次循环，j=1，即以1为头结点的二叉搜索树个数:
dp[3] = dp[3] + dp[1-1] * dp[3-1] = 0 + dp[0] * dp[2] = 0 + 1 * 2 = 2
第二次循环, j=2，即以2为头结点的二叉搜索树个数:
dp[3] = dp[3] + dp[2-1] * dp[3-2] = 2 + dp[1] * dp[1] = 2 + 1 * 1 = 3
第三次循环, j=3，即以3为头结点的二叉搜索树个数:
dp[3] = dp[3] + dp[3-1] * dp[3-3] = 3 + dp[2] * dp[0] = 3 + 2 * 1 = 5
所以我们推出公式: dp[i] = dp[i] + dp[j-1] * dp[i-j];
*/