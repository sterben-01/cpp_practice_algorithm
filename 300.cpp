#include <iostream>
#include <vector>
#include <unordered_set>
#include <set>
#include <unordered_map>
#include <queue>
#include <map>
using namespace std;
/*
!最长递增子序列。注意子序列并不要求连续，而子串要求连续
dp[i]的含义是到nums[i]为止最长上升子序列的长度
也就是到下标为i

?初始化怎么办？
全部初始化为1。因为每一个数字都是一个长度为1的子序列。
?递推公式到底是怎么回事？
举例：
            0   1   0   3   2   3
只要后面的数字比前面大，我们就认为是递增，所以我们有if(nums[i] > nums[j])
!j是哪来的？
我们这儿的i是到i为止。所以每一轮也就是每一个区间我们都需要从头遍历一次，所以j开始位置是0，到i为止。每一次的区间都是0~i

为什么要dp[j]+1。dp[j]的意思是到j为止的最长子序列。j一定小于i。当我们遍历到j的时候发现下标为j的这个数比下标为i的这个数小，我们就在dp[i]的位置+1。表明从j开始到i的区间内 到下标i为止最长子串的长度现在是更新为dp[i]
*dp[i]在子循环的for里面更新了j+1次
!这里有一个误区。我们还是看例子
*index      0   1   2   3   4   5
----------------------------------
*nums       0   1   0   3   2   3
?初始化     1   1   1   1   1   1
?第一轮i=1  1   2   ...                 这里我们j下标从0开始。当为0的时候发现0 < 1 所以我们dp[i]的位置是dp[j]的数+1 而不是单纯的+1.这里就是1+1 = 2
?第二轮i=2  1   2   1   ...             这里我们j下标从0开始。当为1的时候发现1 > 0。 不递增所以不进行操作
?第三轮i=3  1   2   1   3   ...         这里的顺序是这样的 i = 3, nums[i] = 3

                                        初始化dp[3] = 1     nums[j] < nums[i]
                                        第一轮dp[j = 0]     0 < 3。确认递增。dp[3] = dp[0] + 1 = 1 + 1 = 2
                                        第二轮dp[j = 1]     1 < 3。确认递增。更新dp[3] = dp[1] + 1 = 2 + 1 = 3
                                        !第三轮dp[j = 2]    0 < 3。确认递增。更新dp[3] = dp[2] + 1 = 1 + 1 = 2
                                        *上面的第三轮是错误的。我们发现这时候数比上一轮小了。所以我们要和dp[i]去取一个max。 注意是和dp[i]不是dp[i-1]。因为我们dp[i]更新过了。
                                        *注意这道题和i-1没有任何关系。因为到i为止的子序列长度和到i-1为止的子序列长度没有任何关系。所以正确的第三轮是这样的
                                        ?第三轮dp[j = 2]    0 < 3。确认递增。更新dp[3] = max(dp[3], dp[2] + 1) = max(3, 1+1) = max(3, 2) = 3.

?第四轮i=4  1   2   1   3   1   ...     这里的顺序是这样的 i = 4, nums[i] = 2。初始化dp[4] = 1
            1   2   1   3   2   ...     第一轮dp[j = 0]     0 < 3。确认递增。dp[4] = max(dp[4], dp[0] + 1) = max(1,1 + 1) = 2
            1   2   1   3   3   ...     第二轮dp[j = 1]     1 < 3。确认递增。更新dp[4] = max(dp[4], dp[1] + 1) = max(2, 2+1) = 3
            1   2   1   3   3   ...     第三轮dp[j = 2]     0 < 3。确认递增。更新dp[4] = max(dp[4], dp[2] + 1) = max(3, 1+1) = max(3, 2) = 3
            1   2   1   3   3   ...     第四轮dp[j = 3]     3 > 2。不递增。  不更新dp[4]。
最终结果：
?第四轮i=4  1   2   1   3   3   ...

下面就按照这个继续                                       
    ...
!注意 从上面我们分析了dp[i]在每一个j的for循环里都是更新了j+1次。这就是为什么每次dp[j]+1要和dp[i]取max。
*/
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if(nums.size() <2){
            return 1;
        }
        vector<int>dp(nums.size(),1);
        int res = 0;
        for(int i = 1; i < nums.size(); i++){
            for(int j = 0; j < i; j++){
                if(nums[i] > nums[j]){ //注意这里是nums[i]和nums[j]比较不是dp[i]和dp[j]
                    dp[i] = max(dp[i], dp[j] + 1); //逐一分析的递推公式
                }
            }
            if(res < dp[i]){ //保存每一轮的最大值。
                res = dp[i];
            }

        }
        return res;    //返回最大值
    }
};