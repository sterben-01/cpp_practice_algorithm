#include <iostream>
#include <string>
#include <memory>
#include <queue>
#include <vector>
#include <functional>
#include <unordered_map>
#include <algorithm>
using namespace std;

/*
text dp[i][j]的含义是存的是长度为i+1的时候以第j个字母为结尾的字符有几种。也就是说最后一位字母是不变的。
长度为1的时候，只有1个字符。所以每个字符自己就是结尾，所以组合只有1种，比如a只有a一种。
为了方便举例子，我们把字母换成数字。
所以我们有
dp[0][0] = 1
dp[0][1] = 1
...
dp[0][26] = 1
%--------------------------------------------------------------
然后我们看第二位。假设我们现在到了第二位为5的时候。我们假设距离为3。那么第二位为5可以取前一位为5-3到5+3的范围。也就是2到8一共7种。
我们知道dp[0][2] ~ dp[0][8]每一个都是1，所以dp[1][5] = 7。
因为我们固定第二位以5结尾，一共可以有25 35 45 55 65 75 85这7种。
由此可以推出。
%--------------------------------------------------------------
然后我们看第三位。假设我们现在到了第三位为5的时候。我们假设距离为3。那么第三位为5可以取前一位为5-3到5+3的范围。也就是2到8一共7种。
我们知道dp[1][2] ~ dp[1][8]中，我们计算出了dp[1][5] = 7,我们同样可以计算出其他位置。
dp[1][2] = dp[0][2-3]~dp[0][2+3] = 1+1+1+1+1+1 = 6
dp[1][3] = dp[0][3-3]~dp[0][3+3] = 1+1+1+1+1+1+1 = 7
dp[1][4] = dp[0][4-3]~dp[0][4+3] = 1+1+1+1+1+1+1 = 7
....
dp[1][8] = dp[0][8-3]~dp[0][8+3] = 1+1+1+1+1+1+1 = 7

因为我们固定第三位以5结尾，假设第二位为5，那么我们有255 355 455 555 655 755 855。对应dp[1][5]
如果第二位为6 那么我们有365 465 565 665 765 865 965. 对应dp[1][6]
....
以此类推，可以得到dp[2][5] = dp[1][5-3] ~ dp[1][5+3] = 6+7+7+7+7+7+7 = 48

%---------------------------------------------------------------
&所以我们可以推出：dp[i][j] = dp[i][j] + dp[i-1][k]; k的取值范围是(k-d ~ k+d]; 这里d是距离
&为了防止越界，我们在0和k-d中取最大值。25和k+d中取最小值。
*/

int countBalancedWords(int n, int d) {
    vector<vector<long long>> dp(n, vector<long long>(26,0));
    int mod = 1000000007;
    for(int i = 0; i < 26; i++){
        dp[0][i] = 1; //初始化
    }
    for(int i = 1; i < n; i++){
        for(int j = 0; j < 26; j++){
            for(int k = max(0,j-d); k <= min(25, j+d); k++){
                dp[i][j] = (dp[i][j] + dp[i-1][k]) % mod; //提前mod防止越界。
            }
        }
    }
    long long ret = 0;
    for(int i = 0; i < 26; i++){
        ret  = (ret + dp[n-1][i]) % mod; //最后累加即可。累加最后一行就可以。也就是达到了要求长度的那一行。
    }
    return (int) ret;
    
}
 
// Driver's Code
int main()
{
    int n = 3;
    cout << "Total strings are : " << countBalancedWords(3,1);
    return 0;
}