#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
/*
*这道题稍微不好想一点，但是递推公式长得和其他的都差不多。也是分两种带前导0和不带前导0的。这里是带前导0的。方便初始化。第二种懒得写了。
首先我们有两个字符串。这里不具体举例子，影响理解。但是我们应该能推测出来一共是三种。增加一个字符，删除一个字符和替换一个字符这三种操作。
?我们dp[i][j]的意思是将从字符串1的前i个字符组成的子字符串中转变成从字符串2的前j个字符组成的子字符串需要的操作数
!为了增强理解，我将三种操作分别举三个例子。
TODO:第一种操作，替换：
我们有两个字符串，分别是abc和abd。我们自然而然的想到了替换操作，也就是把c换成d。
这里不难理解，我们要找到abc的子字符串'ab'组成abd的子字符串'ab'需要多少操作。然后在这个情况上+1即可。
所以我们有dp[i][j] = dp[i-1][j-1] + 1
&这里需要注意的替换怎么理解。我们题目的意思是字符串A换成B需要多少次操作。所以我们可以增强理解为， 比如 abc和abd。我们找到abc的子字符串'ab'组成abd的子字符串'ab'需要多少操作。然后我们要把c换成d。所以+1即可。而不是abc的ab+c然后abd的ab+c然后算出来是+2，这样是错的。
@7/17更新
TODO:第二种操作，删除：
我们有两个字符串，分别是abcd和abc。我们自然而然想到了删除操作，也就是去掉结尾的d。
什么是删除操作？删除，替换，添加都是具象的表达。他们背后隐藏的都是从上一个操作状态+1的这种情况。
我们这里就是dp[i-1][j] + 1;
为什么是[i-1][j]呢。因为我们要找到abcd的子字符串abc组成abc的子字符串abc需要多少操作。这时候我们发现字符串1后面还有个d，我们就需要把这个字符删掉。
找abcd的子字符串abc就是[i-1]。abc的子字符串abc就是[j]
也就是我们abc组成abc的操作数上+1。+1意味着进行了一次操作。在这种情况下，我们把这种操作叫删除操作。所以操作数+1。
这种操作背后的文字逻辑也就是。将字符串abcd变成abc所需要的操作次数是将字符串abc变成abc所需要的操作次数+1（删除操作）。
TODO：第三种操作，添加：
我们有两个字符串，分别是abc和abcd。我们自然而然想到了添加操作。//!注意不要看其他题解的在字符串1中删除等于在字符串2中添加。不合逻辑而且不会有助于理解
这个和上一个删除操作差不多。
我们这里就是dp[i][j-1] + 1;
为什么是[i][j-1]呢。因为我们发现字符串2后面还有个d，而我们字符串1没有。我们就需要把这个字符添加进字符串1。
所以我们要找到abc的子字符串abc组成abcd的子字符串abc需要多少操作之后添加一次操作即可。
我们不需要考虑添加的字母是什么。这都是具象表达。我们只知道需要进行一次添加操作即可。
!这里可能稍微有点文字写的不合逻辑。意思是什么呢，我们把字符串从abc变成abcd的话怎么变？我们找到abc变成abc需要的操作数，然后加上1就可以了。
也就是abc的子字符串abc组成abcd的子字符串abc需要的操作数+1
找abc的子字符串abc就是[i]。abcd的子字符串abc就是[j-1]

TODO: 额外情况也就是字符相等的情况。那么这个时候无需操作就直接dp[i][j] = dp[i-1][j-1] 即可

TODO:进行取最小值。
?如何初始化？
我们把abcd和""空串相比，需要进行四次操作。也就是逐步删掉
所以我们有
for(int i = 0; i < word1.size() + 1; i++){
    dp[i][0] = i;
}

我们把""空串和abcd相比，也需要四次操作。也就是逐步添加。
所以我们有
for(int i = 0; i < word2.size() + 1; i++){
    dp[0][i] = i;
}
*/



class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>>dp (word1.size()+1, vector<int>(word2.size()+1, 0));
        for(int i = 0; i < word1.size() + 1; i++){
            dp[i][0] = i;
        }
        for(int i = 0; i < word2.size() + 1; i++){
            dp[0][i] = i;
        }
        for(int i = 1; i < word1.size()+1; i++){
            for(int j = 1; j < word2.size()+1; j++){
                if(word1[i-1] == word2[j-1]){ //减1是因为数组错位。
                    dp[i][j] = dp[i-1][j-1];
                }
                else{
                    dp[i][j] = min({dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1});// 递推公式在上方总结了
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};