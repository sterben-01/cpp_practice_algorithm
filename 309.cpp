#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

/*
这道题可以用模板进行解决。
这道题说我可以进行尽可能多的交易。也就是任意多。所以我们不需要k
如果告诉交易次数限制，那就是有k 我们就一样有
dp[i][0][k] = max(dp[i - 1][0][k], dp[i - 1][1][k] + prices[i])
冷却时间1天，所以要从 i - 2 天转移状态
买入，卖出 ---- 冷冻期 ----  买入，卖出
dp[i][1][k] = max(dp[i - 1][1][k], dp[i - 2][0][k - 1] - prices[i])
                                                    ↑今日如果买入了，一定要和昨天的k差1.
*/

/*
但是这道题不需要k所以我们可以去掉k
dp[i][0]指的是第i天不持股时身上所剩金额
dp[i][1]指的是第i天持股时身上所剩金额
!重点：今日持股和今日不持股是两种分离状态。这两种状态无关联！你不可能今天持股又不持股因为不可以单日买卖。
首先是第i天不持股:
    如果i-1天也不持股那就不变 dp[i-1][0]
    如果i-1天持股，那就是直接卖出+price。 所以我们有dp[i-1][1] + price[i] 注意这里是price[i] 是用昨天持股时身上剩余的金额加上今天卖出的股价。因为是今天所以是i
    然后两者取max 我们有 dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
第i天持股：
    如果i-1天也持股。那就不变。dp[i-1][1]
    !重点：如果i-1天不持股，但是今天要持股。那么就是说我们今日要买入。
    !我们今天买入，那么意味着i-1天不能买入因为有1天冷冻期。但是我们不能保证i-1天不买入。
    !所以我们要想今天买入，那就要就要看i-2天身上剩下的钱是多少。我们用i-2天不持股时剩下的钱再减掉今日股价就是今天身上剩下的钱。
    *所以我们有dp[i-2][0] - price[i]
    两者取max 我们有 dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]);
*/
/*
? 那我们初始化应该怎么办呢？
我们知道：
dp[0][0] = 0 因为第1天不持股时默认金额是0
dp[0][1] = -price[0] 因为第1天持股就是买入股票，身上的金额就是今日股票金额的相反数
*直接按照递推公式：我们有
dp[1][0] = max(dp[0][0], dp[0][1] + prices[1]) 因为按照地推公式昨天不持股，今天也不持股就是0
                                            昨天持股今天不持股。那就是今日卖出。就是昨日买入后剩下的钱加上今日卖出的钱也就是今日股价也就是dp[0][1] + prices[1]
                                            !注意第一天股价是prices[1]
?但是，如果是dp[1][1] 昨日不持股今日持股呢？
!重点来了。我们今日是第二天。也就是我们只有第一天的操作。我们第一天可以持股，可以不持股。也就是第一天要么买要么不买。第一天无论如何也不可能有卖出操作
所以我们第二天 也就是dp[1]的时候，我们买入股票不会有冷冻期。因为第一天不可能有卖出操作，所以可以直接买。那就直接-prices[1]是今日股价即可。和第1天买入是一样操作
*当然了，我们也有可能昨天持股今日也持股。那就是不卖出。也就是dp[0][1]昨日持股的金额。
然后我们取max。我们有dp[1][1] = max(dp[0][1], -prices[1]]);
                                            

*/




class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.size() < 2){
            return 0;
        }
        vector<vector<int>>dp(prices.size(), vector<int>(2,0));

        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        dp[1][0] = max(dp[0][0], dp[0][1] + prices[1]);
        dp[1][1] = max(dp[0][1], -prices[1]);

        for(int i = 2; i < prices.size(); i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i]);
        }
        return dp[prices.size()-1][0];
    }
};